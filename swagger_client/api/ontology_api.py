# coding: utf-8

"""
    ORR API Documentation

    The main ORR documentation is located at: https://mmisw.org/orrdoc/  __Please note__: - The ORR API is approaching a stable version but is still work in progress.   Please [let us know](https://github.com/mmisw/mmiorr-docs/issues) if you have any   questions or suggestions.  - Besides the documentation itself, this page lets you directly exercise and test the API.   Click on any operation header below to learn more details about it, and see a \"Try it out\" button.  - You can click on the \"Authorize\" button at the top right of this page   (or the `!` icon under the particular operation)   to retrieve an authentication token corresponding to your ORR instance credentials (username and password).   Once authorized, the authentication token will be automatically included in the corresponding request.   You will be able to not only perform the basic `GET` operations,   but also see expanded responses according to your access privileges   as well as perform other operations.  - The \"Try it out\" button will also show the corresponding API call that you can submit   from the command line using [`curl`](https://curl.haxx.se/).  - This API includes administrative operations related with the triple store.   The SPARQL endpoint itself   (located at `http://cor.esipfed.org/sparql` for the MMI ORR instance)   is not described here.   (General SPARQL information can be found [here](https://en.wikipedia.org/wiki/SPARQL),   and regarding the current service used by the ORR to support the SPARQL interface   [here](http://franz.com/agraph/support/documentation/current/http-protocol.html).)  - Actual requests from this page are against the specific endpoint at   `http://cor.esipfed.org/ont`.   # noqa: E501

    OpenAPI spec version: v0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class OntologyApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_ont(self, body, **kwargs):  # noqa: E501
        """Registers a brand new ontology  # noqa: E501

        Performs the registration of a brand new ontology in the registry by the IRI given in the `iri` attribute of the object in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ont(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ont_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ont_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_ont_with_http_info(self, body, **kwargs):  # noqa: E501
        """Registers a brand new ontology  # noqa: E501

        Performs the registration of a brand new ontology in the registry by the IRI given in the `iri` attribute of the object in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ont_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_term(self, body, **kwargs):  # noqa: E501
        """Adds a term to an existing ORR vocabulary  # noqa: E501

        This operation allows to add a new term to an ORR vocabulary. This addition does not generate a new version of the vocabulary.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_term(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostTerm body: Object with information for the term to be added. See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_term_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_term_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_term_with_http_info(self, body, **kwargs):  # noqa: E501
        """Adds a term to an existing ORR vocabulary  # noqa: E501

        This operation allows to add a new term to an ORR vocabulary. This addition does not generate a new version of the vocabulary.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_term_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostTerm body: Object with information for the term to be added. See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_term" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_term`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont/term', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ont(self, iri, user_name, **kwargs):  # noqa: E501
        """Deletes a particular version or a whole ontology entry  # noqa: E501

        This operation allows to unregister a particular version (if the `version` object attribute is given) or a whole ontoloy entry. Besides admins, only an owner of the ontology can perform this operation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ont(iri, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str iri: Ontology IRI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given IRI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ont_with_http_info(iri, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ont_with_http_info(iri, user_name, **kwargs)  # noqa: E501
            return data

    def delete_ont_with_http_info(self, iri, user_name, **kwargs):  # noqa: E501
        """Deletes a particular version or a whole ontology entry  # noqa: E501

        This operation allows to unregister a particular version (if the `version` object attribute is given) or a whole ontoloy entry. Besides admins, only an owner of the ontology can perform this operation.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ont_with_http_info(iri, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str iri: Ontology IRI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given IRI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iri', 'user_name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'iri' is set
        if ('iri' not in params or
                params['iri'] is None):
            raise ValueError("Missing the required parameter `iri` when calling `delete_ont`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `delete_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'iri' in params:
            query_params.append(('iri', params['iri']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'user_name' in params:
            query_params.append(('userName', params['user_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ont_get(self, **kwargs):  # noqa: E501
        """Gets information about registered ontologies or terms  # noqa: E501

        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `iri`, `oiri`, or `tiri` parameter indicates a request for a particular ontology or term.  If none of the `iri`, `oiri`, and `tiri` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ont_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str iri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given IRI, then it will try a \"term request.\" 
        :param str oiri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str tiri: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ont_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ont_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ont_get_with_http_info(self, **kwargs):  # noqa: E501
        """Gets information about registered ontologies or terms  # noqa: E501

        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `iri`, `oiri`, or `tiri` parameter indicates a request for a particular ontology or term.  If none of the `iri`, `oiri`, and `tiri` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ont_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str iri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given IRI, then it will try a \"term request.\" 
        :param str oiri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str tiri: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iri', 'oiri', 'version', 'tiri', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ont_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'iri' in params:
            query_params.append(('iri', params['iri']))  # noqa: E501
        if 'oiri' in params:
            query_params.append(('oiri', params['oiri']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'tiri' in params:
            query_params.append(('tiri', params['tiri']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Ont]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ont(self, **kwargs):  # noqa: E501
        """Updates a given ontology version or adds a new version  # noqa: E501

        Use this operation to create a new version for a registered ontology, or to update an exisiting version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ont(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutOnt body: Ontology object that needs to be registered. Provide the `metadata` attribute to create a new version of an existing ontology solely based on changes on the metadata. For full contents, use `contents`/`format`, or `uploadedFilename`/`uploadedFormat` as described in the `POST /ont` operation. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ont_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.update_ont_with_http_info(**kwargs)  # noqa: E501
            return data

    def update_ont_with_http_info(self, **kwargs):  # noqa: E501
        """Updates a given ontology version or adds a new version  # noqa: E501

        Use this operation to create a new version for a registered ontology, or to update an exisiting version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ont_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutOnt body: Ontology object that needs to be registered. Provide the `metadata` attribute to create a new version of an existing ontology solely based on changes on the metadata. For full contents, use `contents`/`format`, or `uploadedFilename`/`uploadedFormat` as described in the `POST /ont` operation. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ont" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_ont(self, file, format, **kwargs):  # noqa: E501
        """Uploads an ontology file for subsequent registration  # noqa: E501

        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file corresponds to an ontology in a recognized format, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology IRIs found in the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_ont(file, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The supported formats are described in [this section](https://mmisw.org/orrdoc/ontology/new/#supported-ontology-formats) of the documentation. The special value `\"_guess\"` (without quotes) can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be omitted, in such case implying the guess-format behavior.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_ont_with_http_info(file, format, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_ont_with_http_info(file, format, **kwargs)  # noqa: E501
            return data

    def upload_ont_with_http_info(self, file, format, **kwargs):  # noqa: E501
        """Uploads an ontology file for subsequent registration  # noqa: E501

        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file corresponds to an ontology in a recognized format, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology IRIs found in the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_ont_with_http_info(file, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The supported formats are described in [this section](https://mmisw.org/orrdoc/ontology/new/#supported-ontology-formats) of the documentation. The special value `\"_guess\"` (without quotes) can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be omitted, in such case implying the guess-format behavior.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_ont`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `upload_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadedFileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
