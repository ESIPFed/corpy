# coding: utf-8

"""
    ORR Ont API Documentation

    The main ORR documentation is located at: http://mmisw.org/orrdoc/ ``` ###################################################### # NOTE #   OUT-OF-DATE for the time being. # Currently the swagger spec is maintained in the # https://github.com/mmisw/mmiorr-docs repo, which # is served at http://mmisw.org/orrdoc/api/ ###################################################### ``` __Note__: - We are in the process of writing this API documentation.   Please [let us know](https://github.com/mmisw/mmiorr-docs/issues) if you have any   questions or suggestions.  - Besides the documentation itself, this page also allows to directly exercise the API. - Actual requests from this page are against the endpoint at   `http://cor.esipfed.org/sparql`. This may change in a future version in   particular regarding a more general way of exercising the API (regardless   of concrete endpoint), or by allowing the selection of the particular endpoint.  - You can use the \"Authorize\" button above and enter your COR credentials to login   in this API interface. In this way you will be able to perform not only the basic   `GET` operations, but see expanded responses according to your access priviliges   and ontology visibility settings, as well as perform other operations as listed below.   # noqa: E501

    OpenAPI spec version: v0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class OntologyApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_ont(self, body, **kwargs):  # noqa: E501
        """Registers a brand new ontology  # noqa: E501

        Performs the registration of a brand new ontology in the registry by the URI given in the `uri` attribute of the object in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ont(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_ont_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_ont_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def add_ont_with_http_info(self, body, **kwargs):  # noqa: E501
        """Registers a brand new ontology  # noqa: E501

        Performs the registration of a brand new ontology in the registry by the URI given in the `uri` attribute of the object in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_ont_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ont(self, uri, user_name, **kwargs):  # noqa: E501
        """Deletes a particular version or a whole ontology entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ont(uri, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: Ontology URI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given URI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ont_with_http_info(uri, user_name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ont_with_http_info(uri, user_name, **kwargs)  # noqa: E501
            return data

    def delete_ont_with_http_info(self, uri, user_name, **kwargs):  # noqa: E501
        """Deletes a particular version or a whole ontology entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ont_with_http_info(uri, user_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: Ontology URI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given URI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri', 'user_name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `delete_ont`")  # noqa: E501
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params or
                params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `delete_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'user_name' in params:
            query_params.append(('userName', params['user_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ont_get(self, **kwargs):  # noqa: E501
        """Gets information about registered ontologies or terms  # noqa: E501

        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `uri`, `ouri`, or `turi` parameter indicates a request for a particular ontology or term.  If none of the `uri`, `ouri`, and `turi` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ont_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given URI, then it will try a \"term request.\" 
        :param str ouri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str turi: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ont_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ont_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ont_get_with_http_info(self, **kwargs):  # noqa: E501
        """Gets information about registered ontologies or terms  # noqa: E501

        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `uri`, `ouri`, or `turi` parameter indicates a request for a particular ontology or term.  If none of the `uri`, `ouri`, and `turi` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ont_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given URI, then it will try a \"term request.\" 
        :param str ouri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str turi: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri', 'ouri', 'version', 'turi', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ont_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501
        if 'ouri' in params:
            query_params.append(('ouri', params['ouri']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'turi' in params:
            query_params.append(('turi', params['turi']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Ont]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ont(self, **kwargs):  # noqa: E501
        """Updates a given ontology version or adds a new version  # noqa: E501

        Use this operation to create a new version for a registered ontology, or to update an exisiting version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ont(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutOnt body: Ontology object that needs to be registered
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ont_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.update_ont_with_http_info(**kwargs)  # noqa: E501
            return data

    def update_ont_with_http_info(self, **kwargs):  # noqa: E501
        """Updates a given ontology version or adds a new version  # noqa: E501

        Use this operation to create a new version for a registered ontology, or to update an exisiting version.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ont_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutOnt body: Ontology object that needs to be registered
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ont" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_ont(self, file, format, **kwargs):  # noqa: E501
        """Uploads an ontology file for subsequent registration  # noqa: E501

        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file is a valid ontology, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology URIs found in the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_ont(file, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The special value `\"guess\"` can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be skipped, in such case with the \"guess format\" behavior implied.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_ont_with_http_info(file, format, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_ont_with_http_info(file, format, **kwargs)  # noqa: E501
            return data

    def upload_ont_with_http_info(self, file, format, **kwargs):  # noqa: E501
        """Uploads an ontology file for subsequent registration  # noqa: E501

        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file is a valid ontology, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology URIs found in the file.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_ont_with_http_info(file, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The special value `\"guess\"` can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be skipped, in such case with the \"guess format\" behavior implied.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_ont`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `upload_ont`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'format' in params:
            form_params.append(('format', params['format']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ont/upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadedFileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
