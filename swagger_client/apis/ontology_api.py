# coding: utf-8

"""
    ORR API Documentation

    The main ORR documentation is located at: https://mmisw.org/orrdoc/  __Please note__: - The ORR API is approaching a stable version but is still work in progress.   Please [let us know](https://github.com/mmisw/mmiorr-docs/issues) if you have any   questions or suggestions.  - Besides the documentation itself, this page lets you directly exercise and test the API.   Click on any operation header below to learn more details about it, and see a \"Try it out\" button.  - You can click on the \"Authorize\" button at the top right of this page   (or the `!` icon under the particular operation)   to retrieve an authentication token corresponding to your ORR instance credentials (username and password).   Once authorized, the authentication token will be automatically included in the corresponding request.   You will be able to not only perform the basic `GET` operations,   but also see expanded responses according to your access privileges   as well as perform other operations.  - The \"Try it out\" button will also show the corresponding API call that you can submit   from the command line using [`curl`](https://curl.haxx.se/).  - This API includes administrative operations related with the triple store.   The SPARQL endpoint itself   (located at `https://mmisw.org/sparql` for the MMI ORR instance)   is not described here.   (General SPARQL information can be found [here](https://en.wikipedia.org/wiki/SPARQL),   and regarding the current service used by the ORR to support the SPARQL interface   [here](http://franz.com/agraph/support/documentation/current/http-protocol.html).)  - Actual requests from this page are against the specific endpoint at   `https://mmisw.org/ont`. 

    OpenAPI spec version: v0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class OntologyApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def add_ont(self, body, **kwargs):
        """
        Registers a brand new ontology
        Performs the registration of a brand new ontology in the registry by the IRI given in the `iri` attribute of the object in the body. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_ont(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_ont_with_http_info(body, **kwargs)
        else:
            (data) = self.add_ont_with_http_info(body, **kwargs)
            return data

    def add_ont_with_http_info(self, body, **kwargs):
        """
        Registers a brand new ontology
        Performs the registration of a brand new ontology in the registry by the IRI given in the `iri` attribute of the object in the body. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_ont_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PostOnt body: Object with information for the ontology to be registered.  To provide the contents of the ontology you have two options:  - Specify a previously uploaded file (via `POST /ont/upload`) by   providing the corresponding reported filename (in the `uploadedFilename`   field) and format (`uploadedFormat`). There's no need to upload the file   itself again. - Embbed the complete contents in the `contents` field, and provide the associated   format in `format`.  See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_ont`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/ont', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_term(self, body, **kwargs):
        """
        Adds a term to an existing ORR vocabulary
        This operation allows to add a new term to an ORR vocabulary. This addition does not generate a new version of the vocabulary. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_term(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PostTerm body: Object with information for the term to be added. See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_term_with_http_info(body, **kwargs)
        else:
            (data) = self.add_term_with_http_info(body, **kwargs)
            return data

    def add_term_with_http_info(self, body, **kwargs):
        """
        Adds a term to an existing ORR vocabulary
        This operation allows to add a new term to an ORR vocabulary. This addition does not generate a new version of the vocabulary. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_term_with_http_info(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PostTerm body: Object with information for the term to be added. See the `PostOnt` object description for more details.  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_term" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_term`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/ont/term', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_ont(self, iri, user_name, **kwargs):
        """
        Deletes a particular version or a whole ontology entry
        This operation allows to unregister a particular version (if the `version` object attribute is given) or a whole ontoloy entry. Besides admins, only an owner of the ontology can perform this operation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_ont(iri, user_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str iri: Ontology IRI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given IRI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_ont_with_http_info(iri, user_name, **kwargs)
        else:
            (data) = self.delete_ont_with_http_info(iri, user_name, **kwargs)
            return data

    def delete_ont_with_http_info(self, iri, user_name, **kwargs):
        """
        Deletes a particular version or a whole ontology entry
        This operation allows to unregister a particular version (if the `version` object attribute is given) or a whole ontoloy entry. Besides admins, only an owner of the ontology can perform this operation. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_ont_with_http_info(iri, user_name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str iri: Ontology IRI (required)
        :param str user_name: Registered user making the request. Must be an owner of the ontology.  (required)
        :param str version: Particular version to be deleted. If omitted, the whole entry by the given IRI will be unregistered. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iri', 'user_name', 'version']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'iri' is set
        if ('iri' not in params) or (params['iri'] is None):
            raise ValueError("Missing the required parameter `iri` when calling `delete_ont`")
        # verify the required parameter 'user_name' is set
        if ('user_name' not in params) or (params['user_name'] is None):
            raise ValueError("Missing the required parameter `user_name` when calling `delete_ont`")


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'iri' in params:
            query_params.append(('iri', params['iri']))
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'user_name' in params:
            query_params.append(('userName', params['user_name']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/ont', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def ont_get(self, **kwargs):
        """
        Gets information about registered ontologies or terms
        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `iri`, `oiri`, or `tiri` parameter indicates a request for a particular ontology or term.  If none of the `iri`, `oiri`, and `tiri` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ont_get(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str iri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given IRI, then it will try a \"term request.\" 
        :param str oiri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str tiri: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.ont_get_with_http_info(**kwargs)
        else:
            (data) = self.ont_get_with_http_info(**kwargs)
            return data

    def ont_get_with_http_info(self, **kwargs):
        """
        Gets information about registered ontologies or terms
        General ontology or term report according to given parameters, associated ontology visibility, and privilege of the requesting user. All parameters are optional.   Any given `iri`, `oiri`, or `tiri` parameter indicates a request for a particular ontology or term.  If none of the `iri`, `oiri`, and `tiri` parameters is given, this will indicate a query for a list of ontologies. In this case, only a metadata summary is provided for each reported ontology (in particular, no ontology contents per se is reported). Also, other supplied parameters will be used to query for the desired ontologies. For example, with the query paramenter and value `ownerName=acme`, all ontologies owned by the `acme` organization will be considered for reporting. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.ont_get_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str iri: With this parameter the backend will first try an \"ontology request.\" If no ontlogy is registered by the given IRI, then it will try a \"term request.\" 
        :param str oiri: Use this parameter to exclusively make a \"ontology request.\" 
        :param str version: Desired version in the case of an \"ontology request.\" 
        :param str tiri: Use this parameter to exclusively make a \"term request.\" 
        :param str format: Desired format for the response in the case of a single ontology or term request. 
        :return: list[Ont]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['iri', 'oiri', 'version', 'tiri', 'format']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ont_get" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'iri' in params:
            query_params.append(('iri', params['iri']))
        if 'oiri' in params:
            query_params.append(('oiri', params['oiri']))
        if 'version' in params:
            query_params.append(('version', params['version']))
        if 'tiri' in params:
            query_params.append(('tiri', params['tiri']))
        if 'format' in params:
            query_params.append(('format', params['format']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/ont', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='list[Ont]',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_ont(self, **kwargs):
        """
        Updates a given ontology version or adds a new version
        Use this operation to create a new version for a registered ontology, or to update an exisiting version. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_ont(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PutOnt body: Ontology object that needs to be registered. Provide the `metadata` attribute to create a new version of an existing ontology solely based on changes on the metadata. For full contents, use `contents`/`format`, or `uploadedFilename`/`uploadedFormat` as described in the `POST /ont` operation. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_ont_with_http_info(**kwargs)
        else:
            (data) = self.update_ont_with_http_info(**kwargs)
            return data

    def update_ont_with_http_info(self, **kwargs):
        """
        Updates a given ontology version or adds a new version
        Use this operation to create a new version for a registered ontology, or to update an exisiting version. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_ont_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param PutOnt body: Ontology object that needs to be registered. Provide the `metadata` attribute to create a new version of an existing ontology solely based on changes on the metadata. For full contents, use `contents`/`format`, or `uploadedFilename`/`uploadedFormat` as described in the `POST /ont` operation. 
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ont" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/ont', 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def upload_ont(self, file, format, **kwargs):
        """
        Uploads an ontology file for subsequent registration
        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file corresponds to an ontology in a recognized format, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology IRIs found in the file. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_ont(file, format, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The supported formats are described in [this section](https://mmisw.org/orrdoc/ontology/new/#supported-ontology-formats) of the documentation. The special value `\"_guess\"` (without quotes) can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be omitted, in such case implying the guess-format behavior.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.upload_ont_with_http_info(file, format, **kwargs)
        else:
            (data) = self.upload_ont_with_http_info(file, format, **kwargs)
            return data

    def upload_ont_with_http_info(self, file, format, **kwargs):
        """
        Uploads an ontology file for subsequent registration
        This operation allows to upload an ontology file as a preliminary step for subsequent registration via a `POST /ont` request.   Before having to provide other required information for registration, this separated step helps not only in determining that the file corresponds to an ontology in a recognized format, but also in terms of the returned associated information that the user or client application can use for actual registration, for example, regarding possible ontology IRIs found in the file. 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.upload_ont_with_http_info(file, format, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param file file: The file to be uploaded. (required)
        :param str format: Format of the file. The supported formats are described in [this section](https://mmisw.org/orrdoc/ontology/new/#supported-ontology-formats) of the documentation. The special value `\"_guess\"` (without quotes) can be given to let the ORR automatically determine the format. (A future version of this API may allow this parameter to be omitted, in such case implying the guess-format behavior.)  (required)
        :return: UploadedFileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'format']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_ont" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params) or (params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_ont`")
        # verify the required parameter 'format' is set
        if ('format' not in params) or (params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `upload_ont`")


        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']
        if 'format' in params:
            form_params.append(('format', params['format']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'multipart/form-data'])

        # Authentication setting
        auth_settings = ['basicAuth']

        return self.api_client.call_api('/ont/upload', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='UploadedFileInfo',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
